<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Christmas - Font Restoration Edition</title>
    <link href="https://fonts.googleapis.com/css2?family=Mountains+of+Christmas:wght@400;700&family=Dancing+Script:wght@400;700&family=Noto+Sans+SC:wght@300;500&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; background-color: #010204; overflow: hidden; user-select: none; touch-action: none; }
        canvas { display: block; }
        
        /* å¼ºåˆ¶åŠ è½½å­—ä½“ */
        .font-loader { position: absolute; opacity: 0; pointer-events: none; }
        .font-1 { font-family: 'Mountains of Christmas'; }
        .font-2 { font-family: 'Dancing Script'; }

        /* --- 1. æƒŠå–œç›’å­å­—ä½“æ¢å¤ --- */
        #gift-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center; 
            background-color: #010204; z-index: 100; cursor: pointer;
            transition: opacity 1.2s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .text-top { text-align: center; font-family: 'Mountains of Christmas', cursive; margin-bottom: 50px; }
        .gift-for { font-size: 14px; color: rgba(255, 215, 0, 0.7); letter-spacing: 5px; margin-bottom: 5px; font-weight: 700; }
        .dear-friend { font-size: 32px; color: #ffffff; }
        .gift-container { display: flex; flex-direction: column; align-items: center; animation: gift-float 2.5s infinite ease-in-out; }
        .gift-box { width: 120px; height: 120px; background: linear-gradient(135deg, #d40000 0%, #a00000 100%); position: relative; border-radius: 12px; }
        .gift-box::before { content: ''; position: absolute; width: 22px; height: 100%; background: linear-gradient(to right, #cfaf3c, #FFD700, #cfaf3c); left: 50%; transform: translateX(-50%); }
        .gift-box::after { content: ''; position: absolute; height: 22px; width: 100%; background: linear-gradient(to bottom, #cfaf3c, #FFD700, #cfaf3c); top: 50%; transform: translateY(-50%); }
        .bow { position: absolute; top: -25px; left: 50%; transform: translateX(-50%); width: 45px; height: 45px; z-index: 2; }
        .bow-loop-l, .bow-loop-r { position: absolute; width: 48px; height: 40px; border: 10px solid #FFD700; border-radius: 50% 50% 10% 50%; top: -12px; left: -45px; transform: rotate(-20deg); }
        .bow-loop-r { left: 6px; border-radius: 50% 50% 50% 10%; transform: rotate(20deg); }
        .bow-center { position: absolute; width: 24px; height: 24px; background: #FFD700; border-radius: 5px; top: 10px; left: 50%; transform: translate(-50%, -50%); z-index: 3; }
        .text-bottom { margin-top: 35px; color: #FFD700; font-family: 'Mountains of Christmas', cursive; font-size: 16px; }
        @keyframes gift-float { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-15px); } }

        /* --- 2. åœ£è¯æ ‘é¡µé¢å­—ä½“æ¢å¤ --- */
        #overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; opacity: 0; transition: opacity 2s; }
        .top-left-text { position: absolute; top: 30px; left: 20px; font-family: 'Mountains of Christmas', cursive; }
        .merry-christmas { font-size: 28px; color: #FFD700; font-weight: 700; }
        .signature { position: absolute; bottom: 30px; right: 20px; font-family: 'Dancing Script', cursive; font-size: 22px; color: rgba(255, 215, 0, 0.6); }

        /* --- 3. è´ºå¡å¼¹çª—å­—ä½“æ¢å¤ --- */
        #pop-card-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); backdrop-filter: blur(8px); z-index: 199; display: none; opacity: 0; transition: opacity 0.5s; }
        #pop-card {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.8);
            width: 85vw; max-height: 75vh; background: linear-gradient(135deg, #8b0000 0%, #d40000 100%);
            border: 6px solid #ffd700; border-radius: 20px; z-index: 200; display: none; opacity: 0;
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1); padding: 30px; color: #fff; overflow-y: auto;
        }
        #pop-card.active, #pop-card-overlay.active { display: block; opacity: 1; }
        #pop-card.active { transform: translate(-50%, -50%) scale(1); }
        .close-btn { position: absolute; top: 10px; right: 15px; color: #fff; font-size: 30px; cursor: pointer; }
        
        .card-inner { font-family: "Noto Sans SC", sans-serif; }
        .card-inner .title { font-family: 'Dancing Script', cursive; font-size: 28px; color: #ffd700; font-weight: 700; margin-bottom: 10px; display: block; }
        .card-inner p { line-height: 1.8; margin-bottom: 15px; font-weight: 300; letter-spacing: 0.5px; }
        .card-inner .footer { text-align: right; font-size: 26px; color: #ffd700; font-family: 'Dancing Script', cursive; margin-top: 20px; font-weight: 700; }
    </style>
</head>
<body>
    <div class="font-loader font-1">a</div>
    <div class="font-loader font-2">b</div>
    
    <audio id="bgm" loop preload="auto"><source src="christmas.mp3" type="audio/mpeg"></audio>

    <div id="gift-screen" onclick="revealTree()">
        <div class="text-top"><div class="gift-for">GIFT FOR</div><div class="dear-friend">My Dear Friend</div></div>
        <div class="gift-container">
            <div class="gift-box"><div class="bow"><div class="bow-loop-l"></div><div class="bow-loop-r"></div><div class="bow-center"></div></div></div>
            <div class="text-bottom">Tap to open surprise âœ¨</div>
        </div>
    </div>

    <div id="overlay">
        <div class="top-left-text"><div class="merry-christmas">Merry Christmas</div></div>
        <div class="signature">Jeremy</div>
    </div>

    <div id="pop-card-overlay" onclick="closeCard()"></div>
    <div id="pop-card">
        <div class="close-btn" onclick="closeCard()">âœ•</div>
        <div class="card-inner">
            <span class="title">äº²çˆ±çš„æœ‹å‹ï¼Œ</span>
            <p>åœ£è¯å¿«ä¹ï¼ğŸ„âœ¨</p>
            <p>æ„¿è¿™ä¸ªèŠ‚æ—¥ä¸ºä½ å¸¦æ¥æ»¡æ»¡çš„æ¸©æš–ä¸æ¬¢ç¬‘ï¼Œæ„¿æ˜Ÿå…‰ç‚¹äº®ä½ çš„æ¯ä¸€ä¸ªæ„¿æœ›ï¼Œæ„¿å¹³å®‰ä¸å–œä¹å¸¸ä¼´ä½ å·¦å³ã€‚</p>
            <p>ç¥ä½ åœ£è¯å¹¸ç¦ï¼Œæ–°å¹´é¡ºé‚ï¼Œæ¯ä¸€å¤©éƒ½é—ªé—ªå‘å…‰ï¼</p>
            <div class="footer">äºå®¹</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, treeGroup, ribbonMat, starPoints, cardMesh, snowflakes;
        let isRevealed = false, autoRotate = true, lastX = 0, lastPinchDist = 0;
        let raycaster = new THREE.Raycaster(), mouse = new THREE.Vector2();

        function revealTree() {
            if(isRevealed) return;
            const audio = document.getElementById('bgm');
            if(audio) audio.play().catch(()=>{});
            isRevealed = true;
            document.getElementById('gift-screen').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('gift-screen').style.display = 'none';
                document.getElementById('overlay').style.opacity = '1';
                initScene();
            }, 1000);
        }

        // æ¢å¤åŸç‰ˆæµä½“äº”è§’æ˜Ÿ
        function createStar() {
            const count = 18000, geom = new THREE.BufferGeometry(), posArr = new Float32Array(count * 3);
            const R = 1.4, r = 0.55;
            for (let i = 0; i < count; i++) {
                let step = Math.floor(Math.random()*5), t = Math.random();
                let a1 = (step*0.4*Math.PI)-Math.PI/2, am = (step*0.4*Math.PI+0.2*Math.PI)-Math.PI/2, a2 = ((step+1)*0.4*Math.PI)-Math.PI/2;
                let tx, ty;
                if(Math.random()>0.5) { tx=Math.cos(a1)*R+(Math.cos(am)*r-Math.cos(a1)*R)*t; ty=Math.sin(a1)*R+(Math.sin(am)*r-Math.sin(a1)*R)*t; }
                else { tx=Math.cos(am)*r+(Math.cos(a2)*R-Math.cos(am)*r)*t; ty=Math.sin(am)*r+(Math.sin(a2)*R-Math.sin(am)*r)*t; }
                let glow = (Math.random()*Math.random())*0.4, glowAngle = Math.random()*Math.PI*2;
                posArr[i*3] = tx+Math.cos(glowAngle)*glow; posArr[i*3+1] = ty+Math.sin(glowAngle)*glow; posArr[i*3+2] = (Math.random()-0.5)*0.2;
            }
            geom.setAttribute('position', new THREE.BufferAttribute(posArr, 3));
            return new THREE.Points(geom, new THREE.PointsMaterial({ color: 0xffcc00, size: 0.08, transparent: true, blending: THREE.AdditiveBlending }));
        }

        // æ¢å¤åŸç‰ˆæ‰‹å†™ä¿¡å°
        function createCardTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 256; canvas.height = 340;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#b30000'; ctx.fillRect(0,0,256,340);
            ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 15; ctx.strokeRect(10,10,236,320); 
            ctx.fillStyle = '#ffd700'; ctx.textAlign = 'center';
            ctx.font = '700 40px "Dancing Script", cursive'; 
            ctx.fillText('For You', 128, 185); 
            return new THREE.CanvasTexture(canvas);
        }

        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 1, 1000);
            camera.position.set(0, 12, 45);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            treeGroup = new THREE.Group();
            scene.add(treeGroup);

            const tGeom = new THREE.BufferGeometry(), tP = [], tC = [];
            const greenCols = [new THREE.Color(0x05220a), new THREE.Color(0x0a4d1e), new THREE.Color(0x2e8b57)];
            for (let i = 0; i < 50000; i++) {
                let h = Math.random() * 26, theta = Math.random() * Math.PI * 2;
                let r = (26-h) * 0.42 * Math.sqrt(Math.random());
                tP.push(Math.cos(theta)*r, h-10, Math.sin(theta)*r);
                let col = (Math.random() > 0.98) ? new THREE.Color(0xffd700) : (Math.random() > 0.97 ? new THREE.Color(0xbb0000) : greenCols[Math.floor(Math.random()*3)]);
                tC.push(col.r, col.g, col.b);
            }
            tGeom.setAttribute('position', new THREE.Float32BufferAttribute(tP, 3));
            tGeom.setAttribute('color', new THREE.Float32BufferAttribute(tC, 3));
            treeGroup.add(new THREE.Points(tGeom, new THREE.PointsMaterial({ size: 0.12, vertexColors: true })));

            const bCols = [0xbb0000, 0xffd700, 0xeeeeee, 0x1e40af];
            for (let i = 0; i < 50; i++) {
                const ball = new THREE.Mesh(new THREE.SphereGeometry(0.2, 12, 12), new THREE.MeshStandardMaterial({ color: bCols[i%4], emissive: bCols[i%4], emissiveIntensity: 0.4 }));
                let h = Math.random()*22, r = (26-h)*0.38, ang = Math.random()*Math.PI*2;
                ball.position.set(Math.cos(ang)*r, h-10, Math.sin(ang)*r);
                treeGroup.add(ball);
            }

            const rG = new THREE.BufferGeometry(), rP = [], rS = [];
            for (let i = 0; i < 8000; i++) {
                let t = i/8000, y = 15.5 - t*24, r = (26-(y+10))*0.44, ang = t*Math.PI*12;
                rP.push(Math.cos(ang)*r, y, Math.sin(ang)*r); rS.push(Math.random());
            }
            rG.setAttribute('position', new THREE.Float32BufferAttribute(rP, 3));
            rG.setAttribute('aSize', new THREE.Float32BufferAttribute(rS, 1));
            ribbonMat = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 }, uCol: { value: new THREE.Color(0x2a4a7a) } },
                vertexShader: `attribute float aSize; varying float vO; uniform float time; void main() { float f = sin(position.y*0.4+time*2.5+aSize*2.0); vO = pow(f*0.5+0.5,3.0); vec4 mv = modelViewMatrix*vec4(position,1.0); gl_PointSize=(2.2+aSize*2.2)*(250.0/-mv.z); gl_Position=projectionMatrix*mv; }`,
                fragmentShader: `varying float vO; uniform vec3 uCol; void main() { float d=distance(gl_PointCoord,vec2(0.5)); if(d>0.5) discard; gl_FragColor=vec4(mix(uCol,vec3(0.9,0.85,0.7),vO*0.4),vO*pow(max(0.0,1.0-d*2.2),3.0)*0.4); }`,
                transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
            });
            treeGroup.add(new THREE.Points(rG, ribbonMat));

            starPoints = createStar();
            starPoints.position.y = 17.5;
            treeGroup.add(starPoints);

            const snG = new THREE.BufferGeometry(), snP = [];
            for (let i = 0; i < 1500; i++) snP.push((Math.random()-0.5)*100, Math.random()*50, (Math.random()-0.5)*100);
            snG.setAttribute('position', new THREE.Float32BufferAttribute(snP, 3));
            snowflakes = new THREE.Points(snG, new THREE.PointsMaterial({ color: 0xffffff, size: 0.12, transparent: true, opacity: 0.7 }));
            scene.add(snowflakes);

            cardMesh = new THREE.Mesh(new THREE.BoxGeometry(2.5, 3.4, 0.05), new THREE.MeshStandardMaterial({ map: createCardTexture(), side: THREE.DoubleSide }));
            cardMesh.position.set(6, 2, 0);
            treeGroup.add(cardMesh);

            scene.add(new THREE.AmbientLight(0xffffff, 1));
            animate();
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            if(autoRotate && treeGroup) treeGroup.rotation.y += 0.005;
            if(ribbonMat) ribbonMat.uniforms.time.value = time;
            if(starPoints) starPoints.rotation.y += 0.01;
            if(snowflakes) {
                const p = snowflakes.geometry.attributes.position.array;
                for (let i = 1; i < p.length; i += 3) { p[i] -= 0.06; if (p[i] < -20) p[i] = 30; }
                snowflakes.geometry.attributes.position.needsUpdate = true;
            }
            renderer.render(scene, camera);
        }

        function closeCard() { document.getElementById('pop-card').classList.remove('active'); document.getElementById('pop-card-overlay').classList.remove('active'); autoRotate = true; }

        window.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                lastX = e.touches[0].clientX;
                mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);
                if (raycaster.intersectObject(cardMesh).length > 0) {
                    document.getElementById('pop-card').classList.add('active');
                    document.getElementById('pop-card-overlay').classList.add('active');
                    autoRotate = false;
                }
            } else if (e.touches.length === 2) {
                lastPinchDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
            }
            autoRotate = false;
        }, {passive: false});

        window.addEventListener('touchmove', (e) => {
            if (e.touches.length === 1) {
                let deltaX = e.touches[0].clientX - lastX;
                if(treeGroup) treeGroup.rotation.y += deltaX * 0.01;
                lastX = e.touches[0].clientX;
            } else if (e.touches.length === 2) {
                let dist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
                let zoomFactor = dist / lastPinchDist;
                let s = Math.max(0.4, Math.min(2.5, treeGroup.scale.x * zoomFactor));
                treeGroup.scale.set(s, s, s);
                lastPinchDist = dist;
            }
        }, {passive: false});

        window.addEventListener('touchend', () => { if(!document.getElementById('pop-card').classList.contains('active')) autoRotate = true; });
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>
</html>